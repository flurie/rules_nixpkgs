Achieving Portable C++ Toolchains with rules_nixpkgs in Bazel
1. Introduction
1.1. The Promise and Problem
The integration of Nix's powerful package management capabilities with Bazel's sophisticated build orchestration offers significant advantages for managing complex software dependencies, particularly C++ toolchains. Tweag's rules_nixpkgs provides a bridge, enabling developers to leverage the vast collection of packages available in Nixpkgs, including compilers, linkers, and standard libraries, directly within Bazel builds. This promises highly reproducible and precisely defined toolchains, isolated from the host system's configuration.
However, a significant challenge arises from the inherent design of Nixpkgs. Packages built by Nix, including C++ toolchain components, are installed into unique, hash-based paths within the Nix store (typically /nix/store). Binaries within these packages often embed direct runtime dependencies on these specific store paths. This manifests primarily through hardcoded library search paths (RPATH/RUNPATH) and specified dynamic linker (interpreter) paths within the ELF (Executable and Linkable Format) binaries. While ensuring reproducibility within a Nix environment, this tight coupling renders the toolchains non-portable. They cannot function correctly in environments where the exact /nix/store paths are absent, such as typical Continuous Integration (CI) systems, developer machines without an identical Nix setup, or even within Bazel's sandboxed execution environments if they lack access to the host's Nix store. This report focuses specifically on this portability challenge.
1.2. Report Objective and Scope
The primary objective of this report is to conduct a detailed technical analysis of the barriers preventing Nixpkgs-derived C++ toolchains, as integrated via rules_nixpkgs, from being portable within Bazel. It aims to identify, investigate, and evaluate potential solutions to overcome these barriers, ultimately providing a ranked list of approaches based on their feasibility.
For the purpose of this analysis, "portability" is defined as the ability for the core C++ toolchain components (compiler executables, linker executables, essential runtime shared libraries like libstdc++.so, libc.so, libgcc_s.so, and the dynamic linker itself) fetched via rules_nixpkgs to execute correctly within a standard Bazel action sandbox without requiring the original /nix/store paths from which they were built to be present or accessible on the host system or within the sandbox via mechanisms like bind mounts or Nix-specific sandboxing (unless such a mechanism is part of the proposed solution itself, like buildFHSUserEnv).
This investigation will cover:
* The current integration mechanism of rules_nixpkgs.
* The specifics of ELF runtime linking dependencies created by Nixpkgs builds.
* Methods for modifying ELF binaries (e.g., patchelf) within Bazel.
* Strategies for bundling runtime dependencies.
* Nix-native features for relocatability (e.g., nix bundle, buildFHSUserEnv, static linking).
* Leveraging Bazel's C++ toolchain configuration (cc_toolchain_config).
* Existing community efforts and discussions.
Aspects related to Bazel's remote execution capabilities, while potentially impacted by toolchain portability, are explicitly out of scope for this report. The focus remains solely on enabling the toolchain to function correctly in diverse local execution environments typical of Bazel usage.
2. Understanding the Portability Challenge: Nixpkgs Toolchains in Bazel
2.1. rules_nixpkgs Toolchain Integration Mechanism
The rules_nixpkgs repository provides Bazel rules that allow developers to specify dependencies using Nix expressions. These expressions typically reference packages within the Nixpkgs repository. When Bazel requires a dependency defined via rules_nixpkgs, such as a C++ toolchain, the rules invoke Nix commands (like nix-build) to realize the specified Nix derivation. This process builds or downloads the necessary packages, resulting in a set of artifacts located within the immutable Nix store (e.g., /nix/store/hash-gcc-11.3.0, /nix/store/hash-glibc-2.35, etc.).
Once the Nix artifacts are available, rules_nixpkgs translates these Nix store paths into a format Bazel understands. For C++ toolchains, this typically involves creating a CcToolchainProvider instance. This provider is a structured object that informs Bazel's C++ rules about the location and configuration of the toolchain components: the path to the compiler executable (gcc or clang), the linker (ld), system include directories, library directories, and other necessary flags and settings, often defined via an associated cc_toolchain_config rule. rules_nixpkgs essentially maps the outputs of the Nix build (files and directories in /nix/store) to the fields expected by Bazel's CcToolchainProvider.
This integration acts as an abstraction layer, bridging the gap between Nix's content-addressed package management and Bazel's hermetic build philosophy. rules_nixpkgs successfully makes Nix-built artifacts available as inputs to Bazel actions. However, the critical point is that this process, by default, focuses on provisioning the artifacts – telling Bazel where the compiler, linker, and libraries are located (within the Nix store). It does not inherently alter the runtime behavior of these artifacts. The provisioned binaries still contain the hardcoded Nix store path dependencies embedded during their original build by Nixpkgs. Therefore, while rules_nixpkgs makes the toolchain available to Bazel, it doesn't automatically make it portable to environments lacking those specific Nix store paths.
The effectiveness and implementation details of potential portability solutions are also influenced by the granularity of the toolchain definition generated by rules_nixpkgs. Does the generated CcToolchainProvider only specify the paths to the compiler and linker executables, implicitly assuming their runtime dependencies (like libstdc++.so or libc.so) will be found via embedded RPATHs? Or does it explicitly list the paths to these standard libraries as part of the toolchain's library directories? If the latter, Bazel's own mechanisms might be partially leveraged. If the former, portability solutions must focus more heavily on modifying the binaries themselves or manipulating the runtime environment to satisfy dependencies resolved via mechanisms like RPATH. Understanding precisely which artifacts rules_nixpkgs includes in the toolchain definition and how it represents their paths is crucial for designing interventions.
2.2. Root Cause: Nix Store Path Dependencies in ELF Binaries
The root cause of the portability issue lies in how Nixpkgs builds and links software, specifically ELF binaries on Linux systems. When an executable program runs, it often relies on shared libraries (.so files) for common functionality. The process of finding and loading these libraries at runtime is managed by the dynamic linker/loader (e.g., /lib64/ld-linux-x86-64.so.2 on typical x86-64 Linux).
ELF binaries contain information telling the dynamic linker which libraries they need (DT_NEEDED entries) and where to search for them. Nixpkgs utilizes specific ELF features to ensure that binaries find their dependencies within the Nix store, thereby achieving reproducibility and isolation from the host system. However, these same mechanisms create the portability problem:
1. RPATH/RUNPATH: These are attributes embedded in the ELF header (DT_RPATH or DT_RUNPATH) of executables and shared libraries. They contain a list of directories that the dynamic linker should search for shared libraries needed by that specific binary. Nixpkgs extensively uses RPATH/RUNPATH, setting them to absolute paths pointing directly into the /nix/store where the required dependencies reside (e.g., /nix/store/hash-glibc-2.35/lib). This ensures the binary uses the exact version of the library it was built against, but it hardcodes the dependency on that specific Nix store path. If that path doesn't exist in the execution environment, the dynamic linker fails to find the required library. The key difference between them relates to search order precedence relative to the LD_LIBRARY_PATH environment variable: RPATH is searched before LD_LIBRARY_PATH, while RUNPATH is searched after.
2. Interpreter Path: ELF executables specify the absolute path to the dynamic linker they require via the PT_INTERP program header segment. When Nixpkgs builds software, particularly core components like glibc, the resulting executables (including compilers like gcc) often have their PT_INTERP path set to point to the dynamic linker also located within the Nix store (e.g., /nix/store/hash-glibc-2.35/lib/ld-linux-x86-64.so.2). If this specific path to the dynamic linker does not exist on the target system where the Bazel action executes, the operating system kernel cannot even load the dynamic linker to start the program, resulting in an immediate "file not found" error, regardless of library paths.
Consequently, the portability problem is multi-faceted. It's not sufficient to merely ensure that shared libraries like libstdc++.so or libc.so can be found. The dynamic linker itself, specified by the interpreter path, must also be accessible. Any robust solution must address both the library search paths (RPATH/RUNPATH) and the interpreter path embedded within the toolchain's ELF binaries.
Furthermore, the dependency chain is often transitive. A compiler executable (gcc) might have an RPATH pointing to libstdc++.so in the Nix store. That libstdc++.so, in turn, might have its own RPATH pointing to libgcc_s.so or libc.so in different Nix store paths. Simply patching the gcc binary's RPATH to find libstdc++.so in a new location is insufficient if libstdc++.so cannot subsequently find its own dependencies. This implies that portability solutions often require analyzing and potentially modifying the entire transitive closure of ELF binaries within the toolchain package, not just the top-level executables. This adds significant complexity to identifying all necessary components and applying modifications consistently.
3. Potential Solution Pathways
Several strategies can be considered to address the portability limitations of Nixpkgs-derived C++ toolchains within Bazel. These approaches vary significantly in their implementation complexity, performance characteristics, and effectiveness.
3.1. Binary Modification within Bazel (patchelf)
Concept: This approach involves modifying the ELF binaries provided by Nix after they are fetched by rules_nixpkgs but before they are used in Bazel compilation or linking actions. The patchelf utility is a common tool for this purpose, capable of altering key ELF metadata. These modifications would typically occur within a Bazel action (ctx.actions.run defined in Starlark).
Targets for Modification:
* Interpreter Path: The PT_INTERP segment needs to be changed from the Nix store path (e.g., /nix/store/.../ld-linux.so.2) to a path that is guaranteed to exist in the target execution environment. This could be a standard system path like /lib64/ld-linux-x86-64.so.2, but for better hermeticity and portability, it's often preferable to point it to a dynamic linker bundled alongside the toolchain itself within the Bazel execution root.
* RPATH/RUNPATH: The existing RPATH or RUNPATH entries pointing to /nix/store paths must be modified or replaced. The goal is to redirect the dynamic linker's search to a location where the required libraries will be placed within the Bazel action's sandbox.
Strategies for New Paths:
* Relative Paths ($ORIGIN): This is generally the most robust strategy for creating relocatable binaries. patchelf can set RPATH entries containing the special $ORIGIN token, which the dynamic linker interprets as the directory containing the binary itself. By setting an RPATH like $ORIGIN/../lib, the binary will search for libraries in a lib directory adjacent to its own bin directory. This requires carefully arranging the toolchain components (executables and libraries) into a consistent relative structure within the Bazel execution root.
* Bazel Execution Root Anchoring: Alternatively, RPATHs could be set to absolute paths that are valid within the context of Bazel's execution sandbox (e.g., /bazel-execroot/my_project/bazel-out/k8-fastbuild/bin/external/my_nix_toolchain_linux_amd64/lib). This approach works as long as the toolchain is used within that specific execution root structure but lacks true relocatability if the toolchain artifacts were copied elsewhere. Relative paths using $ORIGIN are generally preferred.
Implementation within rules_nixpkgs: This solution would require modifications to the Starlark rules that generate the cc_toolchain target. After rules_nixpkgs fetches the artifacts from Nix, a new Bazel action would be defined. This action would execute patchelf with the appropriate arguments (--set-interpreter, --set-rpath or --force-rpath) on all relevant ELF files within the fetched toolchain (compiler, linker, potentially standard libraries if they are bundled and also contain problematic paths).
A significant consideration is the availability of the patchelf utility itself within the Bazel action sandbox. If patchelf is fetched from the host system, it breaks hermeticity. If patchelf is itself fetched using rules_nixpkgs, it might suffer from the same Nix store path dependency problem it is supposed to solve. This creates a bootstrapping challenge. A viable solution requires either using a pre-patched, portable patchelf binary (e.g., statically linked, or patched to use relative paths itself) as a build tool input, or ensuring the patching action runs within an environment (like one created by nix-shell or buildFHSUserEnv) where the Nix-provided patchelf can find its own dependencies.
Executing patchelf introduces a performance overhead. While patching a single file is typically fast, applying it to numerous binaries and libraries within a complex toolchain adds a non-negligible cost, primarily impacting the initial setup or analysis phase when the toolchain is first processed. Bazel's caching mechanisms should mitigate this cost on subsequent builds, making it a one-time setup penalty per toolchain version. However, this overhead needs to be weighed against the benefits of portability.
The complexity of this approach is further increased by the need to handle transitive dependencies. As noted earlier (Section 2.2), patching only the top-level executables (like gcc) might not be sufficient if the libraries they load (like libstdc++.so) also contain hardcoded Nix store paths (RPATHs or even interpreter paths if they are scripts invoking other binaries). A robust implementation must identify all ELF files within the toolchain package that require modification and patch them consistently, likely using relative $ORIGIN-based paths reflecting a planned bundled layout. This requires careful dependency analysis, potentially involving tools like ldd or recursive scanning of ELF headers within the fetched artifacts.
3.2. Dependency Bundling
Concept: This strategy involves collecting all necessary runtime shared library dependencies (e.g., libstdc++.so, libc.so, libgcc_s.so, potentially even the dynamic linker ld-linux.so.2) and packaging them together with the toolchain executables within the structure defined by the Bazel toolchain rule. Instead of relying on RPATHs pointing outside this structure (to /nix/store), the toolchain becomes largely self-contained.
This approach is almost always used in conjunction with the patchelf approach described above (Section 3.1). After bundling the dependencies, patchelf is used to modify the toolchain binaries' RPATHs to point within the bundle (e.g., using $ORIGIN/../lib) and to set the interpreter path to the bundled dynamic linker.
Identifying Dependencies: A crucial step is accurately identifying the complete set of runtime dependencies for the toolchain. rules_nixpkgs would need to incorporate logic, likely executed during the Nix build or in a subsequent analysis step, to determine this closure. The Nix command nix-store -qR <toolchain-derivation-path> is often used for this, as it queries the runtime closure of a given store path. The identified dependency paths would then be copied into a defined layout within the Bazel toolchain structure.
Structuring the Bundle: A conventional layout might place executables (compiler, linker) in a bin/ subdirectory and all bundled shared libraries (including the dynamic linker) in a lib/ subdirectory within the Bazel toolchain's output directory. Binaries in bin/ would then be patched to have an RPATH of $ORIGIN/../lib and their interpreter set to $ORIGIN/../lib/ld-linux-x86-64.so.2 (adjusting the path as needed based on the exact structure). The CcToolchainProvider generated by rules_nixpkgs would reference the executables in this bin/ directory.
The most significant drawback of bundling is the increase in the size of the toolchain artifact managed by Bazel. Instead of potentially sharing dependencies via the Nix store (if available), each toolchain bundle duplicates potentially large libraries like glibc. This impacts storage requirements, download times for fetching the toolchain (especially in CI environments), and potentially network transfer for remote caching, although the toolchain itself is typically cached effectively by Bazel. This trade-off exchanges the runtime path dependency problem for increased artifact size.
Another challenge lies in the accuracy of dependency discovery. While nix-store -qR captures build-time and most runtime dependencies declared in Nix derivations, it might not capture everything, especially libraries loaded dynamically at runtime using dlopen() based on configuration or plugins. Over-inclusion (bundling unnecessary libraries) bloats the toolchain artifact, while under-inclusion leads to difficult-to-diagnose runtime failures within Bazel actions. Ensuring complete dependency capture might require additional heuristics, manual curation, or empirical testing, adding fragility to the process.
3.3. Nix-Native Relocatability Approaches
Concept: This category explores leveraging features or techniques within Nix itself that aim to produce more relocatable or self-contained artifacts, potentially reducing the need for extensive post-processing (like patchelf) within Bazel.
nix bundle: The nix bundle command is a relatively recent Nix feature designed to package Nix applications and their closures into distributable formats like AppImages or Docker images. One could investigate bundling the C++ toolchain derivation using nix bundle. However, nix bundle is still somewhat experimental, and its output formats are primarily aimed at application distribution, not necessarily providing the structured set of compiler/linker/libraries/headers expected by Bazel's cc_toolchain rules. The resulting bundle might be a single executable or archive that requires unpacking and reorganization before Bazel can use it, potentially negating the benefits over a manual bundling approach combined with patchelf. Its suitability for creating Bazel toolchains remains uncertain and requires investigation.
buildFHSUserEnv: Nix provides buildFHSUserEnv (and its interactive counterpart nix-shell -p --run) to create environments that simulate a standard Filesystem Hierarchy Standard (FHS) layout. It achieves this using namespaces (typically mount namespaces) to overlay the Nix store paths of the toolchain and its dependencies onto standard locations like /usr/bin, /usr/lib, etc., within a temporary sandbox. Instead of patching the toolchain binaries, Bazel actions could be wrapped to execute within such an FHS environment. The toolchain binaries, retaining their original Nix store paths in RPATH and interpreter, would function correctly because those paths would be simulated within the FHS environment. This cleverly avoids binary modification. However, the significant drawback is performance. Setting up the FHS environment (involving namespace creation and mounts) incurs overhead for every single action that uses the toolchain (e.g., every C++ compilation). For builds with thousands of actions, this cumulative runtime overhead could lead to substantial build slowdowns compared to the one-time cost of patching binaries using patchelf.
Static Linking: Conceptually, the simplest way to eliminate runtime shared library dependencies is to link the toolchain components statically. If the compiler, linker, and all their internal libraries were combined into single executables with no external .so dependencies (except perhaps the system call interface via libc), portability would be greatly enhanced. Nixpkgs does provide mechanisms for attempting static compilation (e.g., using pkgsStatic). However, fully static linking of complex C++ toolchains like GCC or Clang, especially against glibc, is often impractical or unsupported. glibc itself relies heavily on dynamic loading for components like the Name Service Switch (NSS). Even if the compiler/linker could be made static, the standard libraries (libstdc++.so, libc.so) needed by the code compiled by the toolchain would still typically need to be dynamic unless the target application itself is also fully statically linked, which is often undesirable or infeasible. Therefore, while appealing, pursuing fully static toolchains via Nixpkgs is generally not considered a viable general-purpose solution.
3.4. Bazel Environment Configuration (cc_toolchain_config)
Concept: This approach avoids modifying the toolchain binaries (except potentially the interpreter path) and extensive bundling. Instead, it leverages Bazel's C++ toolchain configuration mechanism (cc_toolchain_config) to manipulate the execution environment of compile and link actions. Specifically, it focuses on using the LD_LIBRARY_PATH environment variable.
Implementation: rules_nixpkgs would need to identify the Nix store paths containing the required shared libraries for the toolchain (e.g., /nix/store/hash-glibc-2.35/lib, /nix/store/hash-gcc-libs-11.3.0/lib). It would then generate a cc_toolchain_config definition containing action_config entries for C++ compile and link actions. These entries would prepend the identified Nix store library paths to the LD_LIBRARY_PATH environment variable within the Bazel action sandbox. When the dynamic linker searches for libraries, it would consult LD_LIBRARY_PATH and find the dependencies in their original Nix store locations (assuming those locations are somehow made available, e.g., via host access or network mounts if not strictly adhering to the portability definition).
A critical limitation is that this approach, by itself, does not solve the interpreter path problem. If a toolchain binary specifies an interpreter in /nix/store/.../ld-linux.so.2, setting LD_LIBRARY_PATH is ineffective because the program fails before the dynamic linker even starts searching for libraries based on LD_LIBRARY_PATH. Therefore, this strategy must be combined with at least patching the interpreter path using patchelf --set-interpreter to point to a valid linker (either system-provided or bundled).
Furthermore, relying on LD_LIBRARY_PATH can be fragile. The dynamic linker's search order is complex. If the toolchain binaries have RUNPATH set (which Nix sometimes uses instead of or alongside RPATH), LD_LIBRARY_PATH is typically searched after the RUNPATH directories. If the required library is found via RUNPATH first (pointing to a non-existent /nix/store path), the LD_LIBRARY_PATH setting will not help for that specific dependency. Conversely, if RPATH is used, LD_LIBRARY_PATH is usually ignored unless the RPATH search fails. The exact behavior depends on the linker options used when building the Nix package. Additionally, setting LD_LIBRARY_PATH globally within the action environment can have unintended side effects, potentially causing subprocesses invoked by the toolchain to load incompatible libraries if multiple versions exist across the specified paths.
If this approach were combined with partial bundling (e.g., bundling libstdc++ but relying on LD_LIBRARY_PATH for libc), the interactions could become complex. Does the bundled libstdc++ (potentially with an unmodified RPATH) find the libc specified via LD_LIBRARY_PATH, or does it fail trying to use its original RPATH? Careful testing would be required. While seemingly simpler by avoiding extensive patching or bundling, the LD_LIBRARY_PATH approach introduces potential runtime fragility and is incomplete without addressing the interpreter path.
3.5. Community Landscape and Existing Solutions
Action: Before embarking on implementing any complex solution, it is crucial to investigate existing efforts within the relevant communities. This involves systematically searching public repositories, issue trackers, and forums:
* GitHub issues and pull requests for the tweag/rules_nixpkgs repository itself.
* Nix community forums (e.g., NixOS Discourse).
* Bazel community channels (e.g., Bazel Slack, GitHub discussions, mailing lists).
* General web searches for terms like "rules_nixpkgs portability", "bazel nix toolchain rpath", "nix bazel relocatable toolchain".
Goal: The objective is to determine if this specific portability problem has already been addressed, either partially or completely. Identifying existing forks, branches, specific commits, or detailed proposals can save significant effort and provide valuable insights or reusable code patterns. Understanding why previous attempts might have stalled or failed is equally important.
Discovering prior art confirms the problem's relevance and potentially accelerates the development of a solution. Conversely, a lack of established solutions might indicate that the problem is genuinely challenging within the constraints of Nix and Bazel, or that it hasn't been a high priority for the maintainers or community, setting realistic expectations for the implementation effort required.
Furthermore, community discussions often surface subtle complexities, edge cases, or platform-specific issues (e.g., differences in dynamic linking behavior between Linux and macOS, interactions with other Bazel rulesets) that might not be apparent from a purely theoretical analysis. User reports and developer discussions provide valuable real-world context that can inform the design of a more robust and reliable solution.
4. Comparative Analysis and Feasibility Ranking
4.1. Evaluation Criteria
To systematically compare the potential solutions, the following criteria are used:
* Implementation Complexity: The estimated effort required to implement the solution within the rules_nixpkgs framework. This includes changes to Starlark rules, potential modifications to Nix expressions, handling dependencies (like patchelf), and the complexity of dependency analysis logic.
* Build Performance Impact: Overhead added to the Bazel build process, specifically during the analysis phase or toolchain setup (e.g., time spent running patchelf).
* Action Runtime Performance Impact: Overhead added to the execution time of each Bazel action using the toolchain (e.g., the cost of setting up an FHS environment via buildFHSUserEnv).
* Portability Effectiveness: How completely the solution eliminates the runtime dependency on /nix/store paths. Does it reliably handle both library paths (RPATH/RUNPATH) and the interpreter path? Does it produce a toolchain usable across different Linux environments (assuming basic ABI compatibility)?
* Maintainability: The long-term viability of the solution. How complex is it to understand, debug, and adapt to future changes in Nix, Bazel, rules_nixpkgs, or the toolchains themselves? How susceptible is it to breaking due to subtle changes in dependencies or linking behavior?
* Toolchain Size Impact: Whether the solution significantly increases the storage footprint of the toolchain artifact managed by Bazel.
4.2. Solution Comparison Matrix
The table below summarizes the assessment of the primary solution pathways against the evaluation criteria. "Interpreter Patch" refers specifically to using patchelf --set-interpreter.
Solution Pathway
	Implementation Complexity
	Build Perf. Impact (Setup)
	Action Runtime Perf. Impact
	Portability Effectiveness
	Maintainability
	Toolchain Size Impact
	patchelf + Bundling (Relative Paths)
	High
	Medium
	Low
	High
	Medium
	High
	buildFHSUserEnv Wrapper
	Medium
	Low
	High
	High
	Medium
	Low
	cc_toolchain_config (LD_LIBRARY_PATH) + Interpreter Patch
	Medium
	Low
	Low
	Medium
	Low
	Low
	Static Linking (Toolchain)
	Very High / Impractical
	N/A
	Low
	Medium (Incomplete)
	N/A
	Very High
	nix bundle (Current State)
	Medium (Uncertain)
	Low (Uncertain)
	Low
	Uncertain
	Low
	Medium (Uncertain)
	4.3. Feasibility Ranking
Based on the analysis and comparison, the solutions can be ranked by overall feasibility for achieving portable C++ toolchains with rules_nixpkgs in Bazel:
1. patchelf + Dependency Bundling (using Relative Paths):
   * Justification: This approach offers the highest portability effectiveness, addressing both interpreter and library path issues robustly using relative paths ($ORIGIN). While the implementation complexity is high (requiring transitive dependency analysis, careful bundling structure, and robust patchelf execution), the result is a self-contained toolchain with minimal runtime overhead (only a one-time patching cost during setup). The main trade-off is the increased toolchain size. Despite its complexity, this method directly tackles the root cause and aligns well with Bazel's goal of hermeticity once the bundle is created.
   * Feasibility: High (but complex to implement correctly).
2. buildFHSUserEnv Wrapper:
   * Justification: This method also achieves high portability effectiveness by simulating the necessary environment without modifying binaries. Its implementation complexity within rules_nixpkgs might be lower than full bundling/patching, primarily involving wrapping action execution. However, the significant per-action runtime performance impact makes it potentially unsuitable for large C++ projects where build speed is critical. It avoids increasing toolchain size.
   * Feasibility: Medium (viable if runtime performance overhead is acceptable).
3. cc_toolchain_config (LD_LIBRARY_PATH) + Interpreter Patch:
   * Justification: This approach has lower implementation complexity compared to bundling and avoids significant toolchain size increases. However, its portability effectiveness is rated Medium due to the potential fragility of relying on LD_LIBRARY_PATH (search order issues with RUNPATH, potential side effects). It crucially depends on the Nix store paths being accessible at runtime (violating the strict portability definition unless paths are mapped/mounted) and requires separate handling of the interpreter path. Its maintainability might be lower due to the subtle runtime behaviors it relies on.
   * Feasibility: Medium-Low (simpler, but potentially fragile and incomplete).
4. nix bundle:
   * Justification: Due to its experimental status and focus on application distribution rather than Bazel toolchain structures, its direct applicability is uncertain. Significant adaptation might be needed, potentially making it as complex as manual bundling.
   * Feasibility: Low (currently uncertain/immature for this use case).
5. Static Linking (Full Toolchain):
   * Justification: Generally considered impractical for standard C++ toolchains (GCC/Clang) and glibc due to technical challenges and lack of support. Even if partially achievable, it wouldn't solve the need for dynamic standard libraries for compiled code.
   * Feasibility: Very Low / Impractical.
5. Detailed Recommendations
Based on the feasibility ranking, the following recommendations are provided:
5.1. Primary Recommendation: patchelf + Dependency Bundling (Relative Paths)
This approach is recommended as the most robust and effective solution for achieving truly portable Nixpkgs-derived C++ toolchains in Bazel, despite its implementation complexity.
Implementation Guidance:
1. Dependency Identification: Within the rules_nixpkgs logic (likely in the Starlark rule implementation that fetches the Nix derivation), use Nix commands to determine the transitive runtime closure of the core toolchain derivation. nix-store -qR $(nix-build <toolchain_expr>) is the standard command. Filter this list to include necessary executables (compiler, linker, assemblers, etc.) and shared libraries (libc.so*, libstdc++.so*, libgcc_s.so*, ld-linux*.so*, and potentially others specific to the toolchain version). Care must be taken to handle symbolic links correctly, copying the actual files they point to.
2. Bundling Structure: Define a consistent directory structure for the toolchain artifact that Bazel will consume. A common pattern is:
   * ./bin/: Contains the primary toolchain executables (gcc, g++, ld, as, etc.).
   * ./lib/: Contains all bundled shared libraries, including the dynamic linker (ld-linux-*.so*).
   * ./include/: Contains standard C/C++ headers.
   * ./libexec/: May contain helper executables invoked by the main compiler driver.
   * (Other directories as needed for toolchain specifics). The rules_nixpkgs Starlark rule should copy the identified dependencies from their Nix store locations into this structure within a directory managed by Bazel (e.g., using ctx.actions.declare_directory and ctx.actions.run).
3. patchelf Execution: Define a Bazel action that runs after the bundling copy step. This action executes patchelf on the relevant ELF files within the bundle:
   * Interpreter: For all executables in bin/ (and potentially libexec/), use patchelf --set-interpreter../lib/ld-linux-x86-64.so.2 <binary> (adjusting the relative path to the bundled linker as needed).
   * RPATH: For all executables and shared libraries in bin/, lib/, and libexec/ that require runtime library loading, use patchelf --force-rpath '$ORIGIN/../lib' <binary_or_library> (adjusting the relative path to the lib directory). Using --force-rpath overwrites any existing RPATH/RUNPATH. Ensure $ORIGIN is correctly quoted for the shell.
4. Portable patchelf: The patchelf executable used in the Bazel action must itself be portable. Options include:
   * Checking in a statically linked patchelf binary as a tool.
   * Fetching patchelf via rules_nixpkgs and applying this same bundling/patching process to patchelf itself (a recursive solution, potentially complex).
   * Running the patching action within a minimal Nix environment (nix-shell -p patchelf --run "...") if build environment constraints allow. A pre-built, portable patchelf is often the simplest.
5. CcToolchainProvider Generation: The final rules_nixpkgs Starlark rule should generate the CcToolchainProvider pointing to the executables (bin/gcc, bin/ld, etc.) and configuration files within the newly created, patched, and bundled directory structure.
Potential Challenges: Correctly identifying the minimal required set of transitive dependencies; handling complex symbolic link structures within Nix store paths during bundling; ensuring $ORIGIN resolves correctly in all cases; dealing with potential toolchain-specific wrapper scripts or unusual ELF files. Thorough testing across different build scenarios is essential.
5.2. Secondary Recommendation / Alternative: buildFHSUserEnv Wrapper
If the implementation complexity of the primary recommendation is deemed too high, or if the increased toolchain size is unacceptable, using buildFHSUserEnv presents a viable alternative, provided its performance implications are tolerable.
Scenario Preference: This approach might be preferred in environments where build time is less critical than implementation simplicity or minimizing artifact size. It avoids modifying the toolchain binaries directly.
Implementation: Modify the Bazel C++ actions (compile, link) generated by rules_nixpkgs to be wrapped by a script or command that invokes buildFHSUserEnv. This command would take the Nix store paths of the toolchain and its dependencies as input and execute the actual compile/link command within the resulting FHS sandbox.
Limitations: The primary limitation is the per-action runtime overhead, which can significantly slow down builds. It also introduces a dependency on Nix being available at runtime to construct the FHS environment (although the necessary Nix store paths could potentially be fetched/managed by Bazel).
5.3. Approaches to Avoid (Least Feasible)
* Full Static Linking: As discussed, this is generally impractical for modern C++ toolchains and glibc. Avoid pursuing this as a general solution.
* nix bundle (Current State): Until nix bundle matures and potentially offers output formats suitable for direct consumption as a Bazel toolchain structure, relying on it is likely premature and may require significant post-processing.
* LD_LIBRARY_PATH Only: Relying solely on LD_LIBRARY_PATH without patching the interpreter is an incomplete solution. Even with interpreter patching, the fragility associated with LD_LIBRARY_PATH precedence and potential side effects makes it less robust than bundling with relative RPATHs.
6. Conclusion
6.1. Summary of Findings
The use of rules_nixpkgs to provision C++ toolchains from Nixpkgs within Bazel offers compelling reproducibility benefits but suffers from a significant portability problem. This problem stems from Nixpkgs' standard practice of building ELF binaries (executables and shared libraries) with hardcoded runtime dependencies on specific /nix/store paths. These dependencies manifest primarily as absolute paths embedded in the RPATH/RUNPATH ELF headers, used for locating shared libraries, and in the PT_INTERP segment, specifying the dynamic linker itself. Consequently, toolchains fetched via rules_nixpkgs fail to run in Bazel execution environments lacking access to these exact Nix store paths.
Several solution pathways were analyzed: modifying binaries post-fetch using patchelf, bundling dependencies alongside the toolchain, leveraging Nix-native features like buildFHSUserEnv or nix bundle, attempting static linking, and manipulating the Bazel action environment via cc_toolchain_config and LD_LIBRARY_PATH. Each approach presents distinct trade-offs regarding implementation complexity, performance impact (build setup vs. action runtime), portability effectiveness, maintainability, and toolchain size.
6.2. Reiteration of Recommendation
The most feasible and robust approach identified is the combination of dependency bundling and ELF modification using patchelf with relative ($ORIGIN) paths. While involving significant implementation effort (transitive dependency analysis, careful structuring, managing patchelf itself), this method directly addresses both the library path and interpreter path issues, resulting in a self-contained, highly portable toolchain artifact suitable for use within Bazel's sandboxed environments without runtime Nix dependencies. The main trade-off is the increased size of the toolchain artifact.
As a secondary alternative, wrapping toolchain execution within a buildFHSUserEnv environment can achieve portability without binary modification but incurs a potentially significant per-action runtime performance penalty, making it suitable only when build speed is less critical. Approaches relying solely on LD_LIBRARY_PATH are generally less robust and incomplete, while full static linking and nix bundle (in its current form) are considered impractical or immature for this specific use case.
6.3. Future Considerations
The landscape of Nix and Bazel integration is continually evolving. Future developments could influence the optimal solution:
* Maturation of nix bundle: If nix bundle evolves to support output formats more amenable to Bazel toolchain structures, it could become a more viable option.
* Improvements in rules_nixpkgs: The rules_nixpkgs project itself might incorporate built-in solutions or utilities for handling portability, potentially simplifying the implementation of the recommended approach.
* Bazel Toolchain Enhancements: Future Bazel versions might offer more sophisticated mechanisms for managing toolchain environments or dependencies that could be leveraged.
* Nixpkgs Relocatability Efforts: Ongoing efforts within the Nix community to improve package relocatability, while challenging, could eventually reduce the need for extensive post-processing.
Continuously monitoring these developments and engaging with the respective communities will be beneficial for maintaining and improving the portability of Nixpkgs-based toolchains in Bazel.