"""
Rules for importing a portable C++ toolchain from Nixpkgs.

These rules implement a portable C++ toolchain from Nixpkgs that resolves the main issue
with the standard cc toolchain: dependency on Nix store paths. This implementation uses
the patchelf approach to modify ELF binaries, bundling all necessary dependencies and
setting relative paths to make the toolchain work in any environment, even without access
to the original Nix store.

## Rules

* [nixpkgs_cc_portable_configure](#nixpkgs_cc_portable_configure)
"""

load("@bazel_skylib//lib:sets.bzl", "sets")
load("@bazel_tools//tools/build_defs/repo:utils.bzl", "maybe")
load("@rules_nixpkgs_core//:nixpkgs.bzl", "nixpkgs_package")
load(
    "@rules_nixpkgs_core//:util.bzl",
    "ensure_constraints",
    "execute_or_fail",
    "is_bazel_version_at_least",
)
load(
    "@rules_nixpkgs_core//private/cc_toolchain:lib_cc_configure.bzl",
    "get_cpu_value",
    "get_starlark_list",
    "write_builtin_include_directory_paths",
)

def _parse_cc_toolchain_info(content, filename):
    """Parses the `CC_TOOLCHAIN_INFO` file generated by Nix.

    Attrs:
      content: string, The content of the `CC_TOOLCHAIN_INFO` file.
      filename: string, The path to the `CC_TOOLCHAIN_INFO` file, used for error reporting.

    Returns:
      struct, The substitutions for `@rules_nixpkgs_core//private/cc_toolchain:BUILD.tpl`.
    """

    # Parse the content of CC_TOOLCHAIN_INFO.
    #
    # Each line has the form
    #
    #   <key>:<value1>:<value2>:...
    info = {}
    for line in content.splitlines():
        fields = line.split(":")
        if len(fields) == 0:
            fail(
                "Malformed CC_TOOLCHAIN_INFO '{}': Empty line encountered.".format(filename),
                "cc_toolchain_info",
            )
        info[fields[0]] = fields[1:]

    # Validate the keys in CC_TOOLCHAIN_INFO.
    expected_keys = sets.make([
        "TOOL_NAMES",
        "TOOL_PATHS",
        "CXX_BUILTIN_INCLUDE_DIRECTORIES",
        "COMPILE_FLAGS",
        "CXX_FLAGS",
        "LINK_FLAGS",
        "LINK_LIBS",
        "OPT_COMPILE_FLAGS",
        "OPT_LINK_FLAGS",
        "UNFILTERED_COMPILE_FLAGS",
        "DBG_COMPILE_FLAGS",
        "COVERAGE_COMPILE_FLAGS",
        "COVERAGE_LINK_FLAGS",
        "SUPPORTS_START_END_LIB",
        "IS_CLANG",
        "CONLY_FLAGS",
    ])
    actual_keys = sets.make(info.keys())
    missing_keys = sets.difference(expected_keys, actual_keys)
    unexpected_keys = sets.difference(actual_keys, expected_keys)
    if sets.length(missing_keys) > 0:
        fail(
            "Malformed CC_TOOLCHAIN_INFO '{}': Missing entries '{}'.".format(
                filename,
                "', '".join(sets.to_list(missing_keys)),
            ),
            "cc_toolchain_info",
        )
    if sets.length(unexpected_keys) > 0:
        fail(
            "Malformed CC_TOOLCHAIN_INFO '{}': Unexpected entries '{}'.".format(
                filename,
                "', '".join(sets.to_list(unexpected_keys)),
            ),
            "cc_toolchain_info",
        )

    return struct(
        tool_paths = {
            tool: path
            for (tool, path) in zip(info["TOOL_NAMES"], info["TOOL_PATHS"])
        },
        cxx_builtin_include_directories = info["CXX_BUILTIN_INCLUDE_DIRECTORIES"],
        compile_flags = info["COMPILE_FLAGS"],
        cxx_flags = info["CXX_FLAGS"],
        link_flags = info["LINK_FLAGS"],
        link_libs = info["LINK_LIBS"],
        opt_compile_flags = info["OPT_COMPILE_FLAGS"],
        opt_link_flags = info["OPT_LINK_FLAGS"],
        unfiltered_compile_flags = info["UNFILTERED_COMPILE_FLAGS"],
        dbg_compile_flags = info["DBG_COMPILE_FLAGS"],
        coverage_compile_flags = info["COVERAGE_COMPILE_FLAGS"],
        coverage_link_flags = info["COVERAGE_LINK_FLAGS"],
        supports_start_end_lib = info["SUPPORTS_START_END_LIB"] == ["True"],
        is_clang = info["IS_CLANG"] == ["True"],
        conly_flags = info["CONLY_FLAGS"],
    )

def _nixpkgs_cc_portable_toolchain_config_impl(repository_ctx):
    host_cpu = get_cpu_value(repository_ctx)
    cpu_value = repository_ctx.attr.cross_cpu or host_cpu
    darwin = cpu_value == "darwin" or cpu_value == "darwin_arm64" or cpu_value == "darwin_x86_64"

    # We now support Linux (ELF) and macOS (Mach-O)
    cc_toolchain_info_file = repository_ctx.path(repository_ctx.attr.cc_toolchain_info)
    if not cc_toolchain_info_file.exists and not repository_ctx.attr.fail_not_supported:
        return
    info = _parse_cc_toolchain_info(
        repository_ctx.read(cc_toolchain_info_file),
        cc_toolchain_info_file,
    )

    # Generate the cc_toolchain workspace
    bazel_version_match_8, _ = is_bazel_version_at_least("8.0.0")
    unix_toolchain_config = repository_ctx.attr._unix_cc_toolchain_config
    if not bazel_version_match_8:
        # Bazel 7 and prior requires a matching unix_cc_toolchain_config
        # (with the appropriate features for that Bazel version)
        unix_toolchain_config = Label("@bazel_tools//tools/cpp:unix_cc_toolchain_config.bzl")

    repository_ctx.symlink(
        repository_ctx.path(unix_toolchain_config),
        "cc_toolchain_config.bzl",
    )
    repository_ctx.symlink(
        repository_ctx.path(repository_ctx.attr._armeabi_cc_toolchain_config),
        "armeabi_cc_toolchain_config.bzl",
    )

    # A module map is required for clang starting from Bazel version 3.3.0.
    bazel_version_match, bazel_from_source = is_bazel_version_at_least("3.3.0")
    needs_module_map = info.is_clang and (bazel_version_match or bazel_from_source)
    if needs_module_map:
        generate_system_module_map = [
            repository_ctx.path(repository_ctx.attr._generate_system_module_map),
        ]
        repository_ctx.file(
            "module.modulemap",
            execute_or_fail(
                repository_ctx,
                generate_system_module_map + info.cxx_builtin_include_directories,
                "Failed to generate system module map.",
            ).stdout.strip(),
            executable = False,
        )
    cc_wrapper_src = (
        repository_ctx.attr._osx_cc_wrapper if darwin else repository_ctx.attr._linux_cc_wrapper
    )
    repository_ctx.template(
        "cc_wrapper.sh",
        repository_ctx.path(cc_wrapper_src),
        {
            "%{cc}": info.tool_paths["gcc"],
            "%{env}": "",
        },
    )
    if darwin:
        info.tool_paths["gcc"] = "cc_wrapper.sh"
        info.tool_paths["ar"] = info.tool_paths["libtool"]
    write_builtin_include_directory_paths(
        repository_ctx,
        info.tool_paths["gcc"],
        info.cxx_builtin_include_directories,
    )
    repository_ctx.template(
        "BUILD.bazel",
        repository_ctx.path(repository_ctx.attr._build),
        {
            "%{cc_toolchain_identifier}": "local",
            "%{name}": cpu_value,
            "%{modulemap}": ("\":module.modulemap\"" if needs_module_map else "None"),
            "%{supports_param_files}": "0" if darwin else "1",
            "%{cc_compiler_deps}": get_starlark_list(
                [":builtin_include_directory_paths"] + (
                    [":cc_wrapper"] if darwin else []
                ),
            ),
            "%{compiler}": "compiler",
            "%{abi_version}": "local",
            "%{abi_libc_version}": "local",
            "%{host_system_name}": "local",
            "%{target_libc}": "macosx" if darwin else "local",
            "%{target_cpu}": cpu_value,
            "%{target_system_name}": "local",
            "%{tool_paths}": ",\n        ".join(
                ['"%s": "%s"' % (k, v) for (k, v) in info.tool_paths.items()],
            ),
            "%{cxx_builtin_include_directories}": get_starlark_list(info.cxx_builtin_include_directories),
            "%{compile_flags}": get_starlark_list(info.compile_flags),
            "%{cxx_flags}": get_starlark_list(info.cxx_flags),
            "%{link_flags}": get_starlark_list(info.link_flags),
            "%{link_libs}": get_starlark_list(info.link_libs),
            "%{opt_compile_flags}": get_starlark_list(info.opt_compile_flags),
            "%{opt_link_flags}": get_starlark_list(info.opt_link_flags),
            "%{unfiltered_compile_flags}": get_starlark_list(info.unfiltered_compile_flags),
            "%{dbg_compile_flags}": get_starlark_list(info.dbg_compile_flags),
            "%{coverage_compile_flags}": get_starlark_list(info.coverage_compile_flags),
            "%{coverage_link_flags}": get_starlark_list(info.coverage_link_flags),
            "%{supports_start_end_lib}": repr(info.supports_start_end_lib),
            "%{extra_flags_per_feature}": "{}",
            "%{conly_flags}": get_starlark_list(info.conly_flags),
        },
    )

_nixpkgs_cc_portable_toolchain_config = repository_rule(
    _nixpkgs_cc_portable_toolchain_config_impl,
    attrs = {
        "cc_toolchain_info": attr.label(),
        "fail_not_supported": attr.bool(),
        "cross_cpu": attr.string(),
        "_unix_cc_toolchain_config": attr.label(
            default = Label("@rules_nixpkgs_core//private/cc_toolchain:unix_cc_toolchain_config.bzl"),
        ),
        "_armeabi_cc_toolchain_config": attr.label(
            default = Label("@rules_nixpkgs_core//private/cc_toolchain:armeabi_cc_toolchain_config.bzl"),
        ),
        "_generate_system_module_map": attr.label(
            default = Label("@rules_nixpkgs_core//private/cc_toolchain:generate_system_module_map.sh"),
        ),
        "_osx_cc_wrapper": attr.label(
            default = Label("@rules_nixpkgs_core//private/cc_toolchain:osx_cc_wrapper.sh.tpl"),
        ),
        "_linux_cc_wrapper": attr.label(
            default = Label("@rules_nixpkgs_core//private/cc_toolchain:linux_cc_wrapper.sh.tpl"),
        ),
        "_build": attr.label(
            default = Label("@rules_nixpkgs_core//private/cc_toolchain:BUILD.tpl"),
        ),
    },
)

def _nixpkgs_cc_portable_toolchain_impl(repository_ctx):
    cpu = repository_ctx.attr.cross_cpu or get_cpu_value(repository_ctx)
    exec_constraints, target_constraints = ensure_constraints(repository_ctx)

    repository_ctx.file(
        "BUILD.bazel",
        executable = False,
        content = """\
package(default_visibility = ["//visibility:public"])

toolchain(
    name = "cc-toolchain-{cpu}",
    toolchain = "@{cc_toolchain_config}//:cc-compiler-{cpu}",
    toolchain_type = "@rules_cc//cc:toolchain_type",
    exec_compatible_with = {exec_constraints},
    target_compatible_with = {target_constraints},
)

toolchain(
    name = "cc-toolchain-armeabi-v7a",
    toolchain = "@{cc_toolchain_config}//:cc-compiler-armeabi-v7a",
    toolchain_type = "@rules_cc//cc:toolchain_type",
    exec_compatible_with = {exec_constraints},
    target_compatible_with = [
        "@platforms//cpu:arm",
        "@platforms//os:android",
    ],
)
""".format(
            cc_toolchain_config = repository_ctx.attr.cc_toolchain_config,
            cpu = cpu,
            exec_constraints = exec_constraints,
            target_constraints = target_constraints,
        ),
    )

_nixpkgs_cc_portable_toolchain = repository_rule(
    _nixpkgs_cc_portable_toolchain_impl,
    attrs = {
        "cc_toolchain_config": attr.string(),
        "exec_constraints": attr.string_list(),
        "target_constraints": attr.string_list(),
        "cross_cpu": attr.string(),
    },
)

def nixpkgs_cc_portable_configure(
        name = "local_config_cc_portable",
        attribute_path = "",
        nix_file = None,
        nix_file_content = "",
        nix_file_deps = [],
        repositories = {},
        repository = None,
        nixopts = [],
        quiet = False,
        fail_not_supported = True,
        exec_constraints = None,
        target_constraints = None,
        register = True,
        cc_lang = "c++",
        cc_std = "c++0x",
        cross_cpu = "",
        apple_sdk_path = ""):
    """Use a portable CC toolchain from Nixpkgs.

    This is an alternative to nixpkgs_cc_configure that creates a truly portable
    toolchain by bundling all dependencies and patching ELF binaries to remove
    Nix store path dependencies.

    By default, the standard rules_nixpkgs CC toolchain has hardcoded references
    to the Nix store paths in RPATH/RUNPATH and interpreter paths. This makes the
    toolchain non-portable - it can only be used in environments where those exact
    Nix store paths exist.

    This rule creates a portable toolchain by:
    1. Bundling all necessary runtime dependencies
    2. Using patchelf to modify ELF binaries:
       - Setting the interpreter path to a relative path within the bundle
       - Changing RPATH/RUNPATH to use $ORIGIN-relative paths

    This produces a self-contained toolchain that can be used in any environment,
    including CI systems and Bazel's remote execution.

    Args:
      name: Name for the generated toolchain.
      attribute_path: optional, string, Obtain the toolchain from the Nix expression under this attribute path. Uses default repository if no `nix_file` or `nix_file_content` is provided.
      nix_file: optional, Label, Obtain the toolchain from the Nix expression defined in this file. Specify only one of `nix_file` or `nix_file_content`.
      nix_file_content: optional, string, Obtain the toolchain from the given Nix expression. Specify only one of `nix_file` or `nix_file_content`.
      nix_file_deps: optional, list of Label, Additional files that the Nix expression depends on.
      repositories: dict of Label to string, Provides `<nixpkgs>` and other repositories. Specify one of `repositories` or `repository`.
      repository: Label, Provides `<nixpkgs>`. Specify one of `repositories` or `repository`.
      nixopts: optional, list of string, Extra flags to pass when calling Nix. See `nixopts` attribute to `nixpkgs_package` for further details.
      quiet: bool, Whether to hide `nix-build` output.
      fail_not_supported: bool, Whether to fail if `nix-build` is not available.
      exec_constraints: Constraints for the execution platform.
      target_constraints: Constraints for the target platform.
      register: bool, enabled by default, Whether to register (with `register_toolchains`) the generated toolchain and install it as the default cc_toolchain.
      cc_lang: string, `"c++"` by default. Used to populate `CXX_FLAG` so the compiler is called in C++ mode. Can be set to `"none"` together with appropriate `copts` in the `cc_library` call: see above.
      cc_std: string, `"c++0x"` by default. Used to populate `CXX_FLAG` so the compiler uses the given language standard. Can be set to `"none"` together with appropriate `copts` in the `cc_library` call: see above.
      cross_cpu: string, `""` by default. Used if you want to add a cross compilation C/C++ toolchain. Set this to the CPU architecture for the target CPU. For example x86_64, would be k8.
      apple_sdk_path: string, `""` by default. Obtain the default nix `apple-sdk` for the toolchain form the Nix expression under this attribute path.  Uses default repository if no `nix_file` or `nix_file_content` is provided.
    """
    nixopts = list(nixopts)
    nix_file_deps = list(nix_file_deps)

    nix_expr = None
    if nix_file and nix_file_content:
        fail("Cannot specify both 'nix_file' and 'nix_file_content'.")
    elif nix_file:
        nix_expr = "import $(location {})".format(nix_file)
        nix_file_deps.append(nix_file)
    elif nix_file_content:
        nix_expr = nix_file_content
    elif attribute_path:
        nix_expr = "(import <nixpkgs> {{}}).{0}".format(attribute_path)
        attribute_path = None

    if attribute_path:
        nixopts.extend([
            "--argstr",
            "ccType",
            "ccTypeAttribute",
            "--argstr",
            "ccAttrPath",
            attribute_path,
            "--arg",
            "ccAttrSet",
            nix_expr,
            "--argstr",
            "ccLang",
            cc_lang,
            "--argstr",
            "ccStd",
            cc_std,
        ])
    elif nix_expr:
        nixopts.extend([
            "--argstr",
            "ccType",
            "ccTypeExpression",
            "--arg",
            "ccExpr",
            nix_expr,
            "--argstr",
            "ccLang",
            cc_lang,
            "--argstr",
            "ccStd",
            cc_std,
        ])
    else:
        nixopts.extend([
            "--argstr",
            "ccType",
            "ccTypeDefault",
            "--argstr",
            "ccLang",
            cc_lang,
            "--argstr",
            "ccStd",
            cc_std,
        ])

    if apple_sdk_path:
        nixopts.extend(["--argstr", "appleSDKPath", apple_sdk_path])

    # First, invoke the standard cc.nix to get the base toolchain info
    nixpkgs_package(
        name = "{}_base_info".format(name),
        nix_file = "@rules_nixpkgs_cc//:cc.nix",
        nix_file_deps = nix_file_deps,
        build_file_content = "exports_files(['CC_TOOLCHAIN_INFO'])",
        repositories = repositories,
        repository = repository,
        nixopts = nixopts,
        quiet = quiet,
        fail_not_supported = fail_not_supported,
    )

    # Then, invoke our portable variant that will handle patching and bundling
    nixpkgs_package(
        name = "{}_info".format(name),
        nix_file = "@rules_nixpkgs_cc_portable//:cc_portable.nix",
        nix_file_deps = nix_file_deps + ["@{}_base_info//:CC_TOOLCHAIN_INFO".format(name)],
        build_file_content = "exports_files(['CC_TOOLCHAIN_INFO'])",
        repositories = repositories,
        repository = repository,
        nixopts = nixopts + [
            "--arg",
            "baseToolchainInfo",
            "$(location @{}_base_info//:CC_TOOLCHAIN_INFO)".format(name),
        ],
        quiet = quiet,
        fail_not_supported = fail_not_supported,
    )

    # Generate the `cc_toolchain_config` workspace.
    _nixpkgs_cc_portable_toolchain_config(
        name = "{}".format(name),
        cc_toolchain_info = "@{}_info//:CC_TOOLCHAIN_INFO".format(name),
        fail_not_supported = fail_not_supported,
        cross_cpu = cross_cpu,
    )

    # Generate the `cc_toolchain` workspace.
    if (exec_constraints == None) != (target_constraints == None):
        fail("Both exec_constraints and target_constraints need to be provided or none of them.")
    _nixpkgs_cc_portable_toolchain(
        name = "{}_toolchains".format(name),
        cc_toolchain_config = name,
        exec_constraints = exec_constraints,
        target_constraints = target_constraints,
        cross_cpu = cross_cpu,
    )

    if register:
        maybe(
            native.bind,
            name = "cc_toolchain",
            actual = "@{}//:toolchain".format(name),
        )
        native.register_toolchains("@{}_toolchains//:all".format(name))
